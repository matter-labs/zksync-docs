---
title: ZKsync OS Overview
description: Introduction to ZKsync OS
---

:display-partial{path="/_partials/_zksyncos/_overview"}

### Running Environments

As mentioned before, we have two targets for ZKsync OS. However, this is not just a compilation target, but also how some system primitives
are handled.

The two running environments are:

1. **Forward Running Mode:** To be used in the sequencer. In such mode we expect code to be run on the usual platform with OS,
so default memory allocator can be used (as itâ€™s part of the OS). For non-determinism source, we can just pass Oracle's Rust implementation as a
bootloader input. Some code can be skipped in this mode as well (e.g. merkle proof verification for the storage reads).
2. **Proving Running Mode:** To be used during proof generation. The code runs on a pure RISC-V platform without an OS,
so memory management must be handled manually.
Additionally, special care is needed to pass external data into the RISC-V machine due to the absence of standard non-determinism sources.
All behavior must be fully deterministic and provable.

---

## System Resources

In ZKsync OS, the concept of "resources" is required to limit and charge for both computation (primarily proving) and data usage.
This is more complex than it may initially appear: ZKsync OS is designed to be EVM gas-equivalent,
meaning that EVM code execution should follow the same gas schedule as on Ethereum.

However, the EVM gas schedule does not accurately reflect the cost of ZK proof generation.
To address this mismatch, ZKsync OS introduces [double accounting](/zksync-protocol/zksyncos/double-accounting): tracking both
Execution Environment (EE) gas-equivalent to EVM gas, and a "native" computational resource that models the cost of proving.

## L1 Integration

ZKsync OS is designed for use in ZK rollups and validiums, where state transition correctness must be verified on the settlement
layer (referred to here as L1 for simplicity).

Specifically, a state commitment is stored on L1. For each block or batch, a proof is generated to verify that a valid state transition has occurred
from a known L1 state commitment to a new one based on some set of inputs. This means the state pre and post transition must be included in
the public inputs (or preimage) of the ZK proof.

In addition, the public input will include other components required for:

- Messaging
- Data availability (DA) validation
- Input validation

ZKsync OS also includes a messaging mechanism that enables trustless communication between L1 and L2, fully compatible with
[EraVM](/zksync-protocol/era-vm/transactions/l1_l2_communication). This includes L1 to L2 transactions and L2 to L1 messages.
