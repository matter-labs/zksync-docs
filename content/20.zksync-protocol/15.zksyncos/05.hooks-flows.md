---
title: System Hooks and Runner Flow
description: Learn about System Hooks and Runner Flow
---

## System Hooks

System hooks are special functions that can be triggered by a call on a specific system address. The space for this special addresses is specified
in the [bootloader](/zksync-protocol/zksyncos/bootloader) configuration.

System hooks have two distinct use cases:

- Implementing precompiles à la EVM. We currently support the following precompiles at their EVM addresses:
  - ecrecover
  - sha256
  - ripemd-160
  - identity
  - modexp
  - ecadd
  - ecmul
  - ecpairing
- Implementing system contracts: formal contracts that implement some system functionality, like Era's nonce holder. Needed to support EraVM.
  - L1 messenger system hook

**L1 Messenger System Hook**

The L1 messenger system hook is responsible for sending messages to the L1. Users can call it using the special interface. The input should be encoded as
calldata for the `sendToL1(bytes)` method following the Solidity ABI.

Implementation of the l1 messenger system hook does 2 things: decodes the input and records the message using the system method.

## Runner Flow

This section describes how the bootloader interacts with the execution environments to run contract code. This section is complemented
by [Execution Environments](/zksync-protocol/zksyncos/execution-environment).

**Entrypoints**

The bootloader implements (and uses) two entrypoints for code execution.

The first one is `run_till_completion` from
the [`runner`](https://github.com/matter-labs/zk_ee/blob/main/basic_bootloader/src/bootloader/runner.rs) module of the bootloader. This function
implements the main execution loop given an initial request (either external call or deployment), which is explained in the next section.

The second one,
[`run_single_interaction`](https://github.com/matter-labs/zk_ee/blob/main/basic_bootloader/src/bootloader/run_single_interaction.rs),
is just a simple wrapper over the previous to simplify external calls from the bootloader. It just adds the logic for starting and finishing the
topmost execution frame and prepares the inputs for `run_till_completion`.

**Runner Structure**

The runner's responsibility is to coordinate calls into the execution environments. For this, the runner keeps a callstack of execution
environment states and will be responsible of starting and finishing system frames. Frames are used to take snapshots for storage and memory to
which the system can revert to in case of a failure.

The runner is implemented as an infinite loop that dispatches the preemption reasons returned by the execution environment. As a reminder, these are:

- External call request,
- Deployment request,
- External call completed, and
- Deployment completed.

The runner breaks out of the infinite loop after processing the completion of the initial request (when the callstack becomes empty).

**Call Request**

For the external call request, the bootloader needs to:

1. Start frame for call.
2. Run the call preparation in the system, this will return the callee's bytecode, transfer token value and charge gas according to the EE's policy.
3. Create a new EE state for the call and push it to the callstack.
4. Call into the newly created EE to start executing the frame.

There's a special case in which the callee is a special address (for example, precompile or system contract). In this case the flow is similar,
but there's no new EE. Instead, the [System Hooks](http://localhost:3000/zksync-protocol/zksyncos/hooks-flows) are used.

**Deployment Request**

For deployment request, the bootloader needs to:

1. Start frame for deployment preparation.
2. Call into EE to run deployment preparation. This will compute the deployed address, perform some checks and charge gas.
3. Create the new EE state for the constructor using the output from the previous call and push it to the callstack.
4. Start a frame for the constructor execution.
5. Set nonce to 1 (see EIP-161).
6. Perform token transfer.
7. Call into the newly created EE to start executing the constructor frame.

**Call Completed**

When the EE returns with a completed call, the runner has to:

1. Perform a selfdestruct if the execution ended up in that state.
2. Pop the caller from the callstack.
3. Finish the callee frame, reverting if the execution ended in a reverting state.
4. Copy return data into the return memory of the caller.
5. Continue execution of the caller.

**Deployment Completed**

When the EE returns with a completed deployment, the runner has to:

1. Perform a selfdestruct if the execution ended up in that state.
2. If the constructor execution was successful, ask the system to actually deploy the code.
3. Finish the constructor frame, reverting if the constructor ended in a revert state.
4. Pop the deployer from the callstack.
5. Finish the deployment preparation frame, reverting only if deployment preparations failed.
6. Copy return data into the return memory of the deployer.
7. Continue execution of the deployer.

## Flow Diagram

We illustrate the flow of an interaction in which an EOA transaction execution calls a contract that, in turn, deploys a new contract. The
entry point in the following diagram is `Run single interaction`, which is called by the EOA transaction execution, as described
in [Transaction processing](/zksync-protocol/zksyncos/tx-processing).

![zksyncOS.png](/images/zksyncos-airbender/tx_lifecycle.png)

In this diagram, the dotted lines from the EE to the bootloader are conceptual. In the implementation, the bootloader calls into the EE and
handles the return value in the next iteration of the main loop.
