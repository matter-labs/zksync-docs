---
title: Overview
description: Introduction to ZKsync OS
---

ZKsync is rebuilding the core of the protocol around two complementary
pillars: [**ZKsync Airbender**](/zksync-protocol/zksync-airbender/overview),
a next-generation proof system,
and **ZKsync OS**, a modular execution layer capable of hosting multiple virtual machines.

In this section, we will deep dive into ZKsync OS.

## ZKsync OS: The Execution Layer

ZKsync OS is a system-level implementation for ZKsync's state transition function. It corresponds to the operation layer of ZKsync's new
architecture. It decouples execution from proving. As such, it's responsible for taking block data and the initial state as input and compute the
new state after the application of the block.

ZKsync OS is implemented as a Rust program that will be compiled to two targets. This first one, x86, is used for running in the sequencer.
The second, RISC-V, is fed as an input to the ZKsync Airbender prover to produce the validity proof of the state transition.

## Components of ZKsync OS

ZKsync OS is designed to support multiple VMs. This is needed to seamlessly migrate old Era chains while adding full native EVM equivalence.
In addition, this will allow us to support alt-VMs.

The main components of ZKsync OS are:

- [**Bootloader**](/zksync-protocol/zksyncos/bootloader): The entry point program. It initializes the system and then
runs transactions using two components: the system and the execution environment interpreters.
- [**Execution Environments**](/zksync-protocol/zksyncos/execution-environment): Regular interpreters that take bytecode,
calldata, resources (similar to gas) and some other call context values
as its input. Interpreters are instantiated (with some local state) to execute a frame. When an interpreter sees a call to another contract,
return/revert from current frame, or contract creation it triggers special functionality to process it, as a potentially different
interpreter should be run.
- [**System**](/zksync-protocol/zksyncos/system): Common for all environments and bootloader. Provides abstract interface for
low-level handling of IO (storage, events,
l1 messages, oracles) and memory management. The system communicates with the external oracle (non-determinism source), it’s needed to read block data
, and also for some IO operations, e.g. to perform the initial read for a storage slot.

![zksyncOS.png](/images/zksyncos-airbender/zksyncOS.png)

This modular design enables us to isolate a minimal interface required to implement an Execution Environment. In addition, the system abstraction
makes the storage model customizable and allows for different instances of the entire system.

### Running Environments

As mentioned before, we have two targets for ZKsync OS. However, this is not just a compilation target, but also how some system primitives
are handled.

The two running environments are:

1. **Forward Running Mode:** To be used in the sequencer. In such mode we expect code to be run on the usual platform with OS,
so default memory allocator can be used(it’s part of the OS). For non-determinism source, we can just pass Oracle rust implementation as a
bootloader input. Some code can be skipped in such mode as well(for example merkle proof verification for the storage reads).
2. **Proving Running Mode:** To be used during proofs generation. The code is running on the pure RISC-V platform without OS, so we should manage
memory, also different non-determinism source needed to pass the data inside the RISC-V machine. And we should prove everything.

In order to achieve that we want to have some way to configure the system, as mentioned above - oracle, allocator, disabling/enabling code that
is needed only during proving.
