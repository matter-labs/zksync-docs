---
title: Overview
description: Introduction to ZKsync OS
---

ZKsync is rebuilding the core of the protocol around two complementary
pillars: [**ZKsync Airbender**](/zksync-protocol/zksync-airbender/overview),
a next-generation proof system,
and **ZKsync OS**, a modular execution layer capable of hosting multiple virtual machines.

In this section, we will deep dive into ZKsync OS.

## ZKsync OS: The Execution Layer

ZKsync OS is a system-level implementation for ZKsync's state transition function.
Under ZKsync's new architecture, execution is decoupled from proving.
ZKsync OS acts as the operation layer in this new architecture.
It takes block data and an initial state as input and computes the
new state after the application of the block.

ZKsync OS is implemented as a Rust program that will be compiled to two targets. This first one, x86, is used for running in the sequencer.
The second, RISC-V, is fed as an input to the ZKsync Airbender prover to produce the validity proof of the state transition.

## Components of ZKsync OS

ZKsync OS is designed to support multiple VMs. This is needed to seamlessly migrate old Era chains while adding full native EVM equivalence.
In addition, this will allow us to support alt-VMs.

The main components of ZKsync OS are:

- [**Bootloader**](/zksync-protocol/zksyncos/bootloader): The entry point program. It initializes the system and then
runs transactions using two components: the system and the execution environment interpreters.
- [**Execution Environments**](/zksync-protocol/zksyncos/execution-environment): Regular interpreters that take bytecode,
calldata, resources (similar to gas) and some other call context values
as its input. Interpreters are instantiated with some local state to execute a frame. When an interpreter sees a call to another contract,
return/revert from current frame, or contract creation it triggers special functionality to process it, as a potentially different
interpreter should be run.
- [**System**](/zksync-protocol/zksyncos/system): Common for all environments and the bootloader. Provides an abstract interface for
low-level handling of IO (storage, events,
L1 messages, oracles) and memory management. The system communicates with the external oracle (non-determinism source), which is needed to read block data
, and also for some IO operations, e.g. to perform the initial read for a storage slot.

::centered-container
![zksyncOS.png](/images/zksyncos-airbender/zksyncOS.png)
::

This modular design enables us to isolate a minimal interface required to implement an Execution Environment. In addition, the system abstraction
makes the storage model customizable and allows for different instances of the entire system.

### Running Environments

As mentioned before, we have two targets for ZKsync OS. However, this is not just a compilation target, but also how some system primitives
are handled.

The two running environments are:

1. **Forward Running Mode:** To be used in the sequencer. In such mode we expect code to be run on the usual platform with OS,
so default memory allocator can be used (as itâ€™s part of the OS). For non-determinism source, we can just pass Oracle's Rust implementation as a
bootloader input. Some code can be skipped in this mode as well (e.g. merkle proof verification for the storage reads).
2. **Proving Running Mode:** To be used during proof generation. The code runs on a pure RISC-V platform without an OS,
so memory management must be handled manually.
Additionally, special care is needed to pass external data into the RISC-V machine due to the absence of standard non-determinism sources.
All behavior must be fully deterministic and provable.

---

## System Resources
In ZKsync OS, the concept of "resources" is required to limit and charge for both computation (primarily proving) and data usage.
This is more complex than it may initially appear: ZKsync OS is designed to be EVM gas-equivalent,
meaning that EVM code execution should follow the same gas schedule as on Ethereum.

However, the EVM gas schedule does not accurately reflect the cost of ZK proof generation.
To address this mismatch, ZKsync OS introduces [double accounting](zksync-protocol/zksyncos/overview#double-resource-accounting): tracking both
Execution Environment (EE) gas-equivalent to EVM gas, and a "native" computational resource that models the cost of proving.

## Double Resource Accounting

ZKsyncOS implements a double resource accounting model, where both a Execution Environment resource (EVM gas, for instance) and native resource are tracked.

The interface to interact with resources can be found in [resources.rs](../zk_ee/src/system/resources.rs).

- **Execution Environment Resource: Ergs**

The EE resource is called Ergs, and corresponds to a model for computation performed by Execution Environments.
The current ZKsync OS design assumes every EE will use essentially the same resource for this, but potentially with a different conversion rate.
For example, a unit of EVM gas is currently equivalent to 256 ergs, while a unit of EraVM gas might use a smaller constant for this conversion.

The gas-related fields of ZKsync OS transactions are interpreted as referring to EVM gas.
In general, any reference to the word "gas" in the codebase or docs refer to EVM gas.

Ergs passed to a new EE frame during a call/deployment can be limited as in EVM, in which case the caller will keep the rest of the ergs available.

- **Native Resource**

The native resource models the offchain cost of processing a transaction. Currently, this is dominated by proving and publishing data.
A good intuition for it is "how many risc-v cycles it takes to prove a given computation".

If a transaction execution runs out of native resources, the entire transaction is reverted.
If the same happens during transaction validation, the transaction is considered invalid.

The native resources are passed fully from frame to frame, a call cannot set a limit on how much of it the callee can spend.

### Native Resource Limit

In order to avoid having to use a new custom transaction format, the native resource limit (or native limit) is derived
from the transaction's gas limit and fee. That is, the native limit can be incremented by either increasing the gas limit
or the gas price of the transaction (using priority fee). The idea of using both these fields is to allow users re-use presigned transactions
with a fixed EVM-computed gas limit.

However, if a wallet uses the standard `eth_estimateGas` RPC, the gas estimation will assume no priority fee is added,
and will add enough gas to make sure the transaction has enough native resource to go through.

More precisely, the logic for native resource limit derivation and charging is:

Let:

- `gasPrice` be the transaction's gas price (base fee + priority fee).
- `nativePrice` be a constant set by the operator, reflecting the "cost of processing a single cycle".
Note: for L1->L2 transactions we use a code constant instead of one provided by operator.
- `gasLimit` be the transaction's (EVM) gas limit.

First we define the ratio between EVM gas and native resource as: `nativePerGas := gasPrice/nativePrice`

Note: For call simulation we use a constant for it, as gasPrice might be set to 0.

Next we define the limit for the native resource as: `nativeLimit := gasLimit * nativePerGas`

Then we process the transaction, charging both Ergs for EE execution and native resource for any kind of computation (EE, bootloader or system work).

If execution doesn't run out of native resources, we first charge for pubdata from native resource.
Then we compute the difference between the implicit gas used derived from native resource consumption and the gas used by EEs from the ergs used.
We call this value `deltaGas`.

`deltaGas := (nativeUsed / nativePerGas) - gasUsed`

If `deltaGas > 0`, we add it to `gasUsed` and charge it from ergs. This ensures that gas estimation will include additional gas to cover for
native resources using just base fee. We expect the base fee to be enough to cover most transactions without the need of additional gas.

Finally, refund any remaining gas left is refunded as usual.

---

## L1 Integration

ZKsync OS is designed for use in ZK rollups and validiums, where state transition correctness must be verified on the settlement
layer (referred to here as L1 for simplicity).

Specifically, a state commitment is stored on L1. For each block or batch, a proof is generated to verify that a valid state transition has occurred
from a known L1 state commitment to a new one based on some set of inputs. This means the state pre and post transition must be included in
the public inputs (or preimage) of the ZK proof.

In addition, the public input will include other components required for:

- Messaging
- Data availability (DA) validation
- Input validation

ZKsync OS also includes a messaging mechanism that enables trustless communication between L1 and L2, fully compatible with
[EraVM](https://docs.zksync.io/zksync-protocol/rollup/l1_l2_communication). This includes L1 to L2 transactions and L2 to L1 messages.
