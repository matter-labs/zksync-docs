---
title: Technical Architecture of the EVM Emulator
description:
---

The **EVM Bytecode Emulator** is implemented as a **system contract that interprets and executes EVM bytecode at runtime** within the EraVM environment.
While EVM execution is fully contained within the emulator, it interacts with multiple **system contracts** to ensure correct behavior.

For an overview of **how to deploy and execute EVM contracts**, refer to **[EVM Bytecode Deployment and Execution](./deployment-execution)**.
This page focuses on the **internal mechanics** of the emulator, including gas management, memory layout, and returndata handling.

## Execution Model

When an EVM contract is called, the following steps occur:

1. **Versioned Bytecode Hash Check**
   - The system retrieves the contract’s **versioned hash** from `AccountCodeStorage`.
   - If the version is `0x02` (EVM contract), execution is routed through the **EVM Emulator**.

2. **Bytecode Interpretation**
   - The emulator loads the contract’s **padded bytecode**.
   - It initializes execution context (**EVM stack, memory, storage**).
   - The emulator interprets and executes opcodes.

3. **Gas Accounting and Execution**
   - The **EvmGasManager** system contract handles gas conversion from **EVM gas → EraVM ergs**.
   - Execution continues until completion, error, or out-of-ergs condition.

4. **Return Handling**
   - If execution succeeds, **returndata is forwarded**.
   - If execution fails (`REVERT`, `OUT-OF-ERGS`), **the entire EVM call stack reverts**.

## Gas Management

The **EvmGasManager** system contract is responsible for:

- **Tracking warm/cold storage accesses**.
- **Applying EVM gas costs to opcodes**.
- **Managing EVM call frames**.

See **[EVM Bytecode Deployment and Execution](./deployment-execution#deployment-from-an-evm-contract)** for a high-level explanation.

### Warm/Cold Storage Logic

- **First-time accesses are cold** (higher cost).
- **Subsequent accesses within the same transaction are warm** (lower cost).
- Warm/cold tracking is stored in **transient storage** and resets per transaction.

### EVM Call Frame Management

| **Function** | **Purpose** |
|-------------|------------|
| `pushEVMFrame` | Stores gas and execution context before a call. |
| `consumeEVMFrame` | Retrieves gas and execution context at call entry. |
| `resetEVMFrame` | Cleans up the frame stack on failure. |

If an **EVM contract calls another EVM contract**, gas is tracked using these functions to maintain execution consistency.

## Returndata Handling

Returndata must be preserved across calls. The emulator:

- Stores returndata in an **active memory pointer**.
- Ensures correct returndata for `RETURNDATACOPY`.

For returndata handling in EVM calls, see **[EraVM ↔ EVM Contract Interactions](./era-evm-interactions#returning-data)**.

## Contract Deployment Process

**For a high-level overview of EVM contract deployment, see** **[EVM Bytecode Deployment and Execution](./deployment-execution#contract-deployment)**.

Internally, deployment follows these steps:

1. The emulator calls `precreateEvmAccountFromEmulator` for address derivation.
2. A **temporary bytecode hash** is assigned to mark the contract as an EVM contract.
3. The emulator executes the **constructor** by interpreting the contract’s `initcode`.
4. The final contract bytecode is stored and activated.

## Summary

| **Component** | **Purpose** |
|--------------|------------|
| **EVM Emulator** | Interprets and executes EVM bytecode. |
| **EvmGasManager** | Handles gas conversion and storage tracking. |
| **ContractDeployer** | Deploys EVM contracts and derives addresses. |
| **AccountCodeStorage** | Stores contract bytecode and versioned hashes. |

## Next Steps

- Learn about **[EraVM ↔ EVM contract interactions](./era-evm-interactions)**.
- Review **[differences from Ethereum (Cancun)](./evm-differences)**.
- Explore **[the list of pre deployed contracts](./pre-deployed-contracts)**.
