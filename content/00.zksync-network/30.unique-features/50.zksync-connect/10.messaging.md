---
title: Messaging
description: Learn about how send and verify messages with ZKsync Connect.
---

Interop messaging marks the first step of universal interoperability for the Elastic Network.
Interop messaging enables sending and verifying messages across ZKsync chains via ZKsync Gateway.

An interop message consists of arbitrary data and has two simple properties:

1. Anyone can send a message.
1. Anyone can verify that a given message was successfully sent on some chain.

One example use case for interop messaging would be to unlock experiences on a chain based on activities on another chain.

For a full step-by-step tutorial for sending and verifying interop messages using `zksync-ethers`,
check out the [interop messages guide](/zksync-network/sdk/js/ethers/guides/interop-messages).

## Sending a message

To send a message, you can call the `sendToL1` function on the `L1Messenger` contract, which is pre-deployed on every ZKsync chain at address `0x00..008008`:

```solidity
:code-import{filePath="hardhat-sol/contracts/InteropSendMessage.sol"}
```

The message itself has no destination chain or address. It’s simply a payload created by a user or contract that gets broadcast.
There is no expiration for when messages can be verified. They remain verifiable indefinitely.
The function name `sendToL1` was kept from previous versions for simplicity, although it does not restrict messages from only being verified on the L1.

These messages are the foundation to unlock more complex crosschain activities in the future,
like bridging assets and operate with contracts across different chains.

### Lifecycle of sending a message

1. **Send a Message:** The message is sent via the `sendToL1` method in the L1Messenger contract.
    The naming is leftover from a previous method, but this message first gets sent to Gateway.
1. **Batch created:** The transaction gets included in a batch, which is sent to Gateway.
1. **Chain-batch root added to Gateway Message Root:** The chain-batch root (which includes the log for the message)
    is added to Gateway’s global message root.
    The `MessageRoot` is a contract that collects messages from different chains and aggregates them into a single Merkle tree.
1. **Event emitted:** ZKsync Gateway’s MessageRoot contract emits an event indicating that the interop root was updated.
1. **Event detected:** EthWatch detects the event from a ZKsync chain, stores it in its database,and includes it in the next batch’s bootloader state.
1. **New Root gets stored:** The bootloader calls the `L2InteropRootStorage` contract to update its stored interop roots.
1. **Dependency verification:** The latest batch’s dependency roots are verified against ZKsync Gateway’s `MessageRoot`.
    At this point, the interop root for the batch is confirmed.

## Verifying a message

Messages can be verified using the `proveL2MessageInclusionShared` method
in the L2 message verification contract deployed at `0x..10009` on each ZKsync chain.

```solidity
:code-import{filePath="hardhat-sol/contracts/InteropVerification.sol"}
```

### Lifecycle of verifying a message

1. **Proof Submission:** On any ZKsync chain that uses Gateway, the user calls proveL2MessageInclusionShared
    at the `L2_MESSAGE_VERIFICATION_ADDRESS` (`0x..10009`),
    supplying the message data and a proof of inclusion.
    Note, that this step could be done in the same batch as the dependency verification.
1. Final Verification: The `L2InteropRootStorage` contract is triggered to verify the corresponding
    interop root inclusion on the chain where the proof was submitted.

For more detail about how interoperability works at the protocol level,
visit the [protocol specifications](https://matter-labs.github.io/zksync-era/core/latest/specs/contracts/interop/overview.html) documentation.
