---
title: "Features"
description: "Learn about ZKsync Era’s special features, including native Account Abstraction, Paymasters, and the EVM Bytecode Interpreter"
---

ZKsync Era introduces several protocol-level features that extend Ethereum’s capabilities while maintaining compatibility with existing tools and workflows.
These include **native Account Abstraction**, **Paymasters**, and an **EVM Bytecode Interpreter** for seamless integration with the Ethereum ecosystem.

## Native Account Abstraction

ZKsync Era natively supports **Account Abstraction (AA)**, allowing accounts to include custom logic at the protocol level.
This enables smart accounts that can define how transactions are authorized and executed, unlocking use cases such as:

- Account recovery and social recovery mechanisms
- Native multisignature accounts
- Session keys and programmable spending rules

To learn more about Account Abstraction design, see the [protocol documentation](/zksync-protocol/era-vm/account-abstraction).

If you prefer a practical approach, explore these tutorials:

- [Native multisig smart account](https://code.zksync.io/tutorials/native-aa-multisig)
- [Daily spending limit account](https://code.zksync.io/tutorials/daily-spend-limit-account)

## Paymasters

ZKsync Era also includes native support for **Paymasters**, an extension of the Account Abstraction model introduced
in [EIP-4337](https://eips.ethereum.org/EIPS/eip-4337#extension-paymasters).
Paymasters act as an intermediate layer in transaction processing, controlling how fees are paid or sponsored.

Common use cases include:

- Paying transaction fees in ERC-20 or NFT tokens
- Subsidizing transactions for onboarding or promotions
- Managing fee payments for a predefined set of accounts

For details on Paymaster design, see the [protocol documentation](/zksync-protocol/era-vm/account-abstraction/paymasters).

### Testnet Paymaster

To simplify testing, %%zk_testnet_name%% provides a built-in **testnet paymaster** that supports ERC-20 fee payments.

**Key details**

- **Address**: `0x3cb2b87d10ac01736a65688f3e0fb1b070b3eea3` ([View on explorer](https://sepolia.explorer.zksync.io/address/0x3cb2b87d10ac01736a65688f3e0fb1b070b3eea3))
- **Chain**: %%zk_testnet_name%%
- **Exchange rate**: 1:1 with ETH (1 token unit = 1 wei)
- **Flow type**: Approval-based
- **Usage requirements**:
  - `token`: must match the ERC-20 token used for fee payment
  - `minimalAllowance`: at least `tx.maxFeePerGas * tx.gasLimit`
  - `innerInput`: must be empty (`0x`)

**Example usage**

```ts
const paymasterParams = {
  paymaster: "0x3cb2b87d10ac01736a65688f3e0fb1b070b3eea3",
  paymasterInput: {
    type: "ApprovalBased",
    token: "<ERC20_TOKEN_ADDRESS>",
    minimalAllowance: tx.maxFeePerGas * tx.gasLimit,
    innerInput: "0x",
  },
};
```

This setup lets developers simulate ERC-20-based fee payments in a testnet environment without deploying a custom paymaster.

### Paymaster Tutorials

- [Build an ERC20 custom paymaster](https://code.zksync.io/tutorials/erc20-paymaster)
- [Dapp with gated NFT paymaster](https://code.zksync.io/tutorials/dapp-nft-paymaster)
- [Frontend Quickstart with a Paymaster](https://code.zksync.io/tutorials/frontend-paymaster)
- [Integrate permissionless multi-signer paymaster](https://code.zksync.io/tutorials/permissionless-paymaster)

## EVM Bytecode Interpreter

The **EVM Bytecode Interpreter** in ZKsync Era provides runtime compatibility for Ethereum smart contracts.
It translates EVM instructions into EraVM instructions during execution, allowing developers to deploy contracts compiled with standard
 Ethereum toolchains—without using ZKsync-specific compilers (`zksolc`, `zkvyper`).

This enables development with **Foundry**, **Hardhat**, or **Remix** directly,
without requiring [plugins](../../tooling/hardhat/plugins/hardhat-zksync) or [custom versions](../../tooling/foundry/overview).

### Main Features

- **EVM Bytecode Support** — Run unmodified EVM bytecode without recompilation.
- **Tooling Compatibility** — Use standard Ethereum development tools out of the box.
- **Address Derivation Consistency** — `create` and `create2` behave identically to the EVM.
- **Predeployed Contracts** — Includes `create2`, `multicall3`, and `singletonFactory` (ERC-2470).
  See the [protocol documentation](/zksync-protocol/era-vm/evm-interpreter/pre-deployed-contracts) for a complete list.

### Limitations

- **Debugging** — EVM-compatible debugging tools are not yet supported due to EraVM-specific internals.
- **Gas Model** — EVM gas rules are emulated; actual costs follow the EraVM model. See [EVM gas interpretation](/zksync-protocol/era-vm/evm-interpreter/evm-gas-interpretation).
- **Unsupported Opcodes** — The same opcodes as in EraVM remain unsupported: `CALLCODE`, `SELFDESTRUCT`, `BLOBHASH`, `BLOBBASEFEE`.
- **Transaction Costs** — Bytecode translation introduces overhead, typically increasing costs by 1.5×–4× depending on execution complexity.

Learn more about [differences from Ethereum (Cancun)](/zksync-protocol/era-vm/evm-interpreter/evm-differences).

### Considerations for Developers

The EVM interpreter allows developers to use familiar workflows without custom compilers or plugins.
However, the translated execution model incurs higher gas costs. For production deployments, compiling
contracts to native EraVM bytecode using `zksolc` or `zkvyper` is recommended for optimal performance and efficiency.
