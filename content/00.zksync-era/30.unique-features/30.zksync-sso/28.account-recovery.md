---
title: Account Recovery
description: Get familiar with ZKsync SSO account recovery.
---

In case you lose your passkeys, ZKsync SSO will provide several methods to recover your account.

## Multiple Devices with Passkey Synchronization

Users can synchronize their passkeys across multiple devices using services like iCloud Keychain for Apple devices or similar services on other platforms.
This means if one device is lost, the passkeys are still accessible on other synchronized devices.

## Account Recovery with Guardians

Recovering an account with a Guardian is a **safety feature** designed to help users regain access to their SSO accounts if their primary
authentication method (such as a passkey) is lost.

Users can **initiate the recovery process to update their passkey authentication,** with the Guardian serving as both verifier and facilitator.

### Guardian

A Guardian is a **trusted entity** designated to assist in **recovering access to a smart account**.
It achieves this by signing to verify the legitimacy of the recovery process.

â†’ In other words, another account that acts as a *guardian* of the SSO account, protecting the owner from losing access to it due to the loss of the
primary authentication method.

**Key characteristics include:**

- Can be another smart account with any valid blockchain address.
- Must be explicitly proposed by the SSO account owner.
- Must actively accept the Guardian role.
- Can verify recovery attempts but cannot directly control the account.
- Allows multiple guardians to be assigned to an account.

### Main flows high-level description

#### Adding & Verifying a Guardian

This diagram illustrates the process of adding a new guardian to a user's SSO account.

The flow begins when a user decides to add a guardian and involves communication between the User, Auth Server, and SSO Account to generate and
process a unique invitation that the designated guardian must accept.

![Guardian Setup](/images/zksync-sso/account-recovery/guardiansetup.svg)

#### Recovering an account

This diagram illustrates the step-by-step process of recovering an SSO account when a user has lost access to their primary authentication method.

The flow shows the interactions between the User, Auth Server, and Guardian during the recovery process, including the initial recovery request,
passkey update, guardian verification, and completion of the recovery.

![Guardian Recovery](/images/zksync-sso/account-recovery/guardianrecovery.svg)

#### Stop malicious account recovery

This diagram illustrates how SSO account owners **can detect and stop unauthorized recovery attempts initiated** by a malicious guardian. The flow
shows how users are alerted of pending recoveries during normal SSO login and can cancel suspicious recovery attempts before they are completed.

![Malicious Guardian](/images/zksync-sso/account-recovery/maliciousguardian.svg)

### Module Implementation

The solution centers on a new [ERC7579 inspired validator module](https://docs.zksync.io/zksync-era/unique-features/zksync-sso/account-modules)
called `GuardianRecoveryValidator`. This guide illustrates how to perform different guardian recovery actions with this module:

#### Adding & verifying a Guardian

To link a guardian to a smart account, the account owner must first **propose the guardian**, after which the guardian must **verify and accept**
their role. This ensures **mutual consent** and secure onboarding.

##### **Proposing a Guardian**

The `proposeGuardian` method handles the initial registration of external accounts by:

1. Taking an external account address and storing it as a **pending guardian**.
2. Enabling `addGuardian` to **confirm and activate** this guardian.
3. Emits: `GuardianProposed`.

##### **Verifying a Guardian**

The `addGuardian` method handles the registration of external accounts by:

1. Verifying that the guardian was **previously proposed** by the account.
2. Marking the guardian as **active and ready**.
3. Recording the guardian-to-account relationship for **future recovery and validation**.
4. Emits: `GuardianAdded`.

#### **Removing a Guardian**

The `removeGuardian` method handles guardian removal by:

1. Accepting the guardian's address as input.
2. Removing the guardian from the account's list.
3. Cleaning up associated metadata (e.g., removing the account from the guardian's guarded list).
4. Emitting a **`GuardianRemoved`** event to log the change.

#### **Recovery Process**

The following section detail the technical implementation of initiating, completing, and canceling the recovery process.

##### **Initiating Recovery**

A verified guardian can **initiate account recovery** using the `initRecovery` method, which:

1. Verifies the caller is an **active guardian** of the account.
2. Verifies that account does not have non-expired pending recovery
3. Records a recovery request with:
    - **Hashed credential ID**
    - **Raw public key**
    - **Timestamp**
4. Emits a **`RecoveryInitiated`** event for auditability.
5. The contract enforces:
    1. **Timelock**: Recovery must be **delayed by 24 hours** before it can be executed.
    2. **Expiration**: Recovery must be completed within **72 hours**, else it **expires**.

##### **Completing Recovery**

Account recovery is completed by submitting a specific transaction validated via `validateTransaction`, which:

1. Ensures the transaction calls `WebAuthValidator.addValidationKey`.
2. Confirm the **credential ID and public key** match the recovery request.
3. Verifies that **24 hours have passed** since initiation and the request is within the **72-hour validity window**.
4. Mark recovery as complete by calling `finishRecovery`
5. Emits: **`RecoveryFinished`**

##### **Cancelling Recovery**

A pending recovery can be discarded using `discardRecovery`, which:

1. Removes the recovery request from storage.
2. Emits a **`RecoveryDiscarded`** event for traceability.

## Account Recovery with Google

The solution allows users to link **a Google account as a recovery method** to their SSO account,
and later on, use that Google account to **recover access to their SSO account**, without revealing
their email or information that reveals their identity at any point.

The guide below provides information about the linking and recovery process, with further details about these two main components
in the solution:

- An [ERC7579 inspired validator module](https://docs.zksync.io/zksync-era/unique-features/zksync-sso/account-modules) (`OidcRecoveryValidator`)
  is in charge of managing the recovery data of every SSO account.
- A **ZK circuit** is used to prove the ownership of an account without revealing the account

### Main flows high-level description

We will separate the process into two main moments:

1. **Google Account Linking:** The user links their Google account to their SSO account with the `OidcRecoveryValidator`.
2. **Account Recovery with Google:** The user shows proof of owning a `JWT` issued to the same Google account
   from an auxiliary account and adds a new passkey to their SSO account.

::callout{icon="i-heroicons-light-bulb"}
Throughout this documentation, you'll encounter the term OIDC. Open ID Connect is **an identity authentication protocol**
built on top of OAuth 2.0 to create a standard way of authenticating and authorizing users when they access digital services.
For more information, please refer to the [OIDC documentation](https://openid.net/developers/how-connect-works/).
::

#### **Google account linking to the SSO account**

To use his Google Account for recovery, the user needs to link it to his SSO account. For this, he will request a `JWT`,
extract the necessary data, combine it with the salt, and create a hash of these elements.
Finally, this hash will be registered in the `OidcRecoveryValidator`.

![Google Account Linking](/images/zksync-sso/account-recovery/oidcLinking.svg)

**OIDC Digest**

The JWT has 3 attributes that together identify a Google account: `iss` (issuer), `aud` (audience), and `sub` (subject).
Hashing the 3 of them generates a way to identify the user.

Saving a hash of those 3 is a way to save a reference to the Google account.

To provide extra security, a `salt` is added. This salt is managed by a different entity and works as a second factor of security.

Finally, the digest is calculated as follows:

`PoseidonHash(iss || aud || sub || salt)`

#### **Step 2: Present ownership proof for recovery**

**When users lose access to their account**, they must interact with the `OidcRecoveryValidator` through an auxiliary account
to validate that they have ownership of the account to be recovered.

Since this is a recovery process, users won't have access to their main account when presenting the proof.
Instead, they must submit the proof through an auxiliary account that has enough funds to cover the transaction costs.

OIDC allows users to populate the `nonce` field with custom data. This field contains the recovery data within the `JWT`,
enabling the circuit to verify that the `JWT` was specifically generated for this recovery.

::callout{icon="i-heroicons-light-bulb"}
Through the ZK proof, the system verifies that the Google Account owner is authorizing the SSO account recovery.
Users generate this proof locally on their device, while the contract supplies the public arguments for verification.
::

After completing this process, users can add a new passkey to their SSO account, successfully recovering access to it.

![Google Account Recovery](/images/zksync-sso/account-recovery/oidcRecovery.svg)

### Module Implementation

The [**`OidcRecoveryValidator`**](https://github.com/matter-labs/zksync-sso-clave-contracts/blob/main/src/validators/OidcRecoveryValidator.sol)
is an [ERC7579 inspired validator module](https://docs.zksync.io/zksync-era/unique-features/zksync-sso/account-modules)
that enables zero-knowledge-based account recovery via OpenID Connect (OIDC) identity assertions. It enables user to add a new passkey
if they can prove control over an OIDC identity (e.g., their Google account) previously linked to their SSO account.

#### **Adding & removing linking to OIDC identities**

The following functions manage the linking and unlinking of OIDC identities:

**Account Linking**

The function `addOidcAccount()` links an OIDC identity (`oidcDigest`, `iss`) to a new or existing SSO account.
As a restriction, the `oidcDigest` must not be registered to another account.

- Emits: `OidcAccountUpdated`.

**Remove Linking**

The function `deleteOidcAccount()`  (**and internal `_deleteOidcAccount`)** fully cleans OIDC data,
both from the SSO account and the digest mapping.

- Emits: `OidcAccountDeleted`

#### **Recovery process**

The following functions play a crucial role in the recovery process:

**Initiating Recovery**

`startRecovery()` is called with a zk proof and the hash of the new passkey. It checks the proof by calling the ZK verifier.
If the ZK proof verification fails, this method reverts.

- Emits: `RecoveryStarted`

**Completing Recovery (Validating transaction & updating passkey)**

`validateTransaction()`  validates a transaction that aims to add a new passkey after a successful `startRecovery()`.

- If all checks pass, it resets the recovery state and returns `true`, authorizing the transaction. Otherwise, it returns `false`.

**Cancelling Recovery**

Users can opt to cancel an active recovery at any time before completion, via `cancelRecovery()`.

- Emits: `RecoveryCancelled`.

### Circuit Implementation

::callout{icon="i-heroicons-light-bulb"}
The circuit is implemented in **Circom** and leverages code from [`circomlib`](https://github.com/iden3/circomlib) and [`zkemail`](https://github.com/zkemail).
::

The circuit performs **two key validations:**

- Prove that the user owns a valid JWT signed by Google and issued for the specific Google account.
- Prove that the owner of the JWT had the intention of performing the transaction.

To do this, it **does 4 main operations:**

1. Validate the JWT. This is done by performing the standard JWT validation using RS256 with the Google public key.
2. Parse and extract important data from the JWT: `iss`, `sub`, `aud`, and `nonce`
3. Recreate and validate the OIDC digest.
4. Recreate and validate the content of the nonce.

![OidcCircuit](/images/zksync-sso/account-recovery/oidcCircuit.png)

For more information, please refer to the [Circuit repository](https://github.com/Moonsong-Labs/zksync-social-login-circuit/).

#### **Inputs**

The circuit's inputs fall into three main categories:

**Key elements for validation**

The circuit requires **4 primary inputs, which enable its core validation functions**:

1. **The `JWT`** (private): This is the raw JWT, as sent by Google.
2. **Google's public key** (public).
3. **The expected digest** (public, more on this later): `PoseidonHash(sub || aud || iss || salt)`
4. **The expected content of the nonce** (public): Set by the user and then signed by Google.

**Privacy & ownership**

Two additional inputs are essential for maintaining privacy:

- **Blinding factor** (private): Random value used to avoid revealing the nonce defined by the user.
- **Salt** (private): Deterministic value. Used to create a second factor of security and avoid Google being
  the only custodian of the wallet.

**Optimization & other elements**

Finally, there are several additional inputs used for optimization purposes, such as the indices of all important elements within the JWT.

#### Outputs

Rather than producing an output value, the circuit acts as a validator - it fails if any of the required validations are unsuccessful.

*More account recovery options are coming soon.*

<!--
**Adding another auth page â€” *coming soon**?*
To avoid the reliance on a single trusted domain,
users can create or connect to a ZKsync SSO auth page hosted on a different domain!
By providing their account address, the alternate page can provide a great back-up location for passkeys.
These passkeys could be stored via FIDO device or a different online passkey provider than the primary key.

**Adding another passkey â€” *coming soon***

Users can register a new device by adding a new passkey to their account.
This typically involves verifying their identity on the new device, after which the new passkey is securely associated with their account.

**Recovery via OAuth 2.0 â€” *coming soon***

OAuth Recovery ERC-7579 module enables users to set up an account recovery through OAuth tokens associated with their existing Web2 logins like
Gmail, Facebook, or X (formerly Twitter). This allows users to regain access by logging in with their familiar social media or email accounts.

-->