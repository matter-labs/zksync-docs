---
title: Migrating Hardhat project to ZKsync Era
description: Learn how to migrate an existing Hardhat project to ZKsync Era.
---

## Project setup

The `@matterlabs/hardhat-zksync` plugin includes all the necessary tools to compile, test, deploy, and verify contracts on ZKsync.

::callout{icon="i-heroicons-light-bulb"}
Under the hood, this plugin bundles together several plugins that focused on specific features like compilation, deployment, and verification.
You can [learn more about each plugin in this section of the docs](/build/tooling/hardhat/getting-started).
::

1. Install the `@matterlabs/hardhat-zksync` plugin with:

::code-group

```bash [npm]
npm i -D @matterlabs/hardhat-zksync
```

```bash [yarn]
yarn add -D @matterlabs/hardhat-zksync
```

```bash [pnpm]
pnpm i -D @matterlabs/hardhat-zksync
```

```bash [bun]
bun add @matterlabs/hardhat-zksync
```

::

1. Import the plugin at the top of the `hardhat.config.ts` file:

```ts
import "@matterlabs/hardhat-zksync";
```

1. Add the preferred ZKsync networks to the `hardhat.config.ts` file:

```js
networks: {
    zkSyncSepoliaTestnet: {
      url: "https://sepolia.era.zksync.dev",
      ethNetwork: "sepolia",
      zksync: true,
      verifyURL: "https://explorer.sepolia.era.zksync.dev/contract_verification",
    },
    zkSyncMainnet: {
      url: "https://mainnet.era.zksync.io",
      ethNetwork: "mainnet",
      zksync: true,
      verifyURL: "https://zksync2-mainnet-explorer.zksync.io/contract_verification",
    },
    dockerizedNode: {
      url: "http://localhost:3050",
      ethNetwork: "http://localhost:8545",
      zksync: true,
    },
    inMemoryNode: {
      url: "http://127.0.0.1:8011",
      ethNetwork: "localhost",
      zksync: true,
    },
    // Other networks

}
```

::callout{icon="i-heroicons-light-bulb"}
You can also add the `zksync:true` flag to the `hardhat` network.
::

## Compilation

ZKsync Era (as well as other chains built with ZK Stack) is operated by the EraVM,
which executes a specific bytecode that differs from the EVM.
This bytecode is generated by the `zksolc` (for Solidity contracts)
and `zkvyper` (for Vyper contracts) compilers.

To compile your contracts with these compilers, follow these steps:

::callout{icon="i-heroicons-information-circle" color="blue"}
Make sure the `@matterlabs/hardhat-zksync` plugin is installed and the networks configured as detailed in the [project setup](#project-setup).
::

1. Run the compilation task targeting one of the ZKsync networks, which cointain `zksync: true`:

::code-group

```bash [npm]
npx hardhat compile --network zkSyncSepoliaTestnet
```

```bash [yarn]
yarn hardhat compile --network zkSyncSepoliaTestnet
```

```bash [pnpm]
pnpm hardhat compile --network zkSyncSepoliaTestnet
```

```bash [bun]
bun hardhat compile --network zkSyncSepoliaTestnet
```

::

<!-- markdownlint-disable MD029 -->
2. The following output indicates the contracts are being compiled with the `zksolc` compiler:

```bash
Compiling contracts for ZKsync Era with zksolc v1.5.1 and zkvm-solc v0.8.17-1.0.1
Compiling 42 Solidity files
```
<!-- markdownlint-disable MD029 -->
3. The compiler generates the `/artifacts-zk` and `/cache-zk` folders containing the smart contract correspondent artifacts,
which follow the same structure as the ones generated by the `solc` compiler.

### Compiler settings

You can modify different compiler settings in the `zksolc` or `zkvyper` property inside the `hardhat.config.ts` file.

- Check the [available `zksolc` settings here](/build/tooling/hardhat/hardhat-zksync-solc#configuration).
- Check the [available `zkvyper` settings here](/build/tooling/hardhat/hardhat-zksync-vyper#configuration).

### Non-inline Libraries

Deploying non-inline libraries on ZKsync differs from Ethereum.

On Ethereum, non-inlineable libraries must be deployed beforehand, and then referenced in the deployment transaction of the contract that imports them:

```typescript [Ethereum non-inlineable libraries]
const firstLibrary = await hre.ethers.deployContract("LibraryA");
await firstLibrary.waitForDeployment();
const firstLibraryAddress = await firstLibrary.getAddress()

const secondLibrary = await hre.ethers.deployContract("LibraryB");
await secondLibrary.waitForDeployment();
const secondLibraryAddress = await l2.getAddress();

const mainContract = await hre.ethers.deployContract("MainContract",{
  libraries:{
    LibraryA:firstLibraryAddress,
    LibraryB:secondLibraryAddress
  }
});

await mainContract.waitForDeployment();
```

On ZKsync, if your project contains non-inline libraries,
the compilation command will throw an error.

To automatically deploy all non-inlinable libraries, follow these steps:

1. Configure a deployer account in the ZKsync network you want to deploy by adding the `accounts:[]` property.
2. Run the following command to deploy the libraries and auto-generate the :

::code-group

```bash [npm]
npx hardhat deploy-zksync:libraries
```

```bash [yarn]
yarn hardhat deploy-zksync:libraries
```

```bash [pnpm]
pnpm hardhat deploy-zksync:libraries
```

```bash [bun]
bun hardhat deploy-zksync:libraries
```

::

The command also adds the libraries and its addresses to the `hardhat.config.ts` file.

3. Now you can compile the main contract that imports the libraries and deploy the contract without the need to reference the libraries:

```typescript [ZKsync non-inlineable libraries]
const mainContract = await hre.ethers.deployContract("MainContract")
await mainContract.waitForDeployment();
```

::

### Troubleshoting

**Use of unsupported opcodes like SELFDESTRUCT or EXTCODECOPY.** The compiler will throw an error if any unsupported opcodes is used in one of the contracts.
See [differences with EVM opcodes here](/build/developer-reference/ethereum-differences/evm-instructions#coinbase).

## Testing

ZKSync provides different EraVM node implementations to test smart contracts locally:

- In-Memory Node: fast L2 node with non-persistent state.
- Dockerized setup: L1 and L2 nodes with persistent state but slower performance.

::callout{icon="i-heroicons-information-circle" color="blue"}
Unless your project contains L1-L2 features, testing with the In-Memory Node is recommended.
::

You can read more about each node in the [Testing section of the docs](https://docs.zksync.io/build/test-and-debug).

### Running unit tests on In-Memory Node

To run tests on the In-Memory Node, follow these steps:

::callout{icon="i-heroicons-information-circle" color="blue"}
The In-Memory Node is included in the `@matterlabs/hardhat-zksync` plugin, so make sure it’s installed
and imported in your `hardhat.config.ts` file as detailed in the [project setup](#project-setup).
::

1. Add the `zksync:true` flag to the `hardhat` network in the `hardhat.config.ts` file.
2. Run the test task with `npx hardhat test`.

You can find more info about testing with the In-Memory-Node in [this section of the docs](https://docs.zksync.io/build/tooling/hardhat/hardhat-zksync-node#running-hardhats-test-task-with-hardhat-zksync-node).

### Running tests on Dockerized setup

To run tests on the Dockerized local setup, follow these steps:

1. Run `npx zksync-cli dev config` and select the “Dockerized node” option.
1. Run `npx zksync-cli dev start` to start the L1 and L2 nodes.
1. Add the Dockerized nodes to the list of networks in the `hardhat.config.ts` file:

```bash
networks: {
    dockerizedNode: {
      url: "http://localhost:3050",
      ethNetwork: "http://localhost:8545",
      zksync: true,
    },
    // Other networks

}
```

1. Make sure the providers in your test files target the correct url.
2. Run the test task with `npx hardhat test --network dockerizedNode`.

## Deployment

Smart contract deployment on ZKsync Era (and chains build with ZK Stack) differs from Ethereum
as it’s handled by the `ContractDeployer` system contract
(see [this section of the docs to learn more](https://docs.zksync.io/build/developer-reference/ethereum-differences/contract-deployment)).

There are different approaches for contract deployment detailed next:

::callout{icon="i-heroicons-information-circle" color="blue"}
Make sure the `@matterlabs/hardhat-zksync` plugin is installed and the networks configured as detailed in the [project setup](#project-setup).
::

### Deployment with `hardhat-ethers`

The `@matterlabs/hardhat-zksync` includes `@matterlabs/hardhat-zksync-ethers`, a package that extends `@nomiclabs/hardhat-ethers`
with all the necessary helper methods to deploy contracts on both ZKsync and EVM networks. The injected `hre.ethers`
object provides methods like `deployContract`, `getContractFactory` or `getContractAt` so deployment scripts work out of the box.

::callout{icon="i-heroicons-exclamation-triangle" color="amber"}
To avoid typescript collision errors between `@nomiclabs/hardhat-ethers` and `@matterlabs/hardhat-zksync-ethers` make sure that only the latter
(or the wrapper plugin `@matterlabs/hardhat-zksync`) is imported in the `hardhat.config.ts` file.
::

See below examples for `hardhat-ethers` and `hardhat-zksync-ethers`:

::code-group

```typescript [hardhat-ethers]
const greeter = await hre.ethers.deployContract('Greeter', ['Hi there!']);
await greeter.waitForDeployment();
```

```typescript [hardhat-zksync-ethers]
const greeter = await hre.ethers.deployContract('Greeter', ['Hi there!']);
await greeter.waitForDeployment();
```

::

In-case a custom deployment is needed, use `ContractFactory`.

::code-group

```typescript [hardhat-ethers]
const GreeterFactory = await hre.ethers.getContractFactory('Greeter');
const greeterContract = GreeterFactory.deploy(); // if any, pass constructor arguments in deploy arguments
await greeter.waitForDeployment();
```

```typescript [hardhat-zksync-ethers]
const GreeterFactory = await hre.ethers.getContractFactory('Greeter');
const greeterContract = GreeterFactory.deploy(); // if any, pass constructor arguments in deploy arguments
await greeter.waitForDeployment();
```

::

### Deployment with `hardhat-deploy`

The newest versions of the `hardhat-deploy` plugin (beginning with `0.11.26`) now support ZKsync
deployments right out of the box. This means you no longer need to modify your deployment scripts.

### Deployment with `hardhat-viem`

<!-- TODO: test and compare scripts -->
To be included.

### Deployment with Hardhat ignition

Hardhat ignition scripts do not support deployments to ZKsync Era yet.
Please use any other options like [hardhat-deploy](#deployment-with-hardhat-deploy) or [hardhat-ethers](#deployment-with-hardhat-ethers)

### Migrating from @openzeppelin/contracts-upgradable to hardhat-zksync-upgradeable

The `@matterlabs/hardhat-zksync` includes `@matterlabs/hardhat-zksync-upgradable`,
which extends `@openzeppelin/hardhat-upgrades` with all the necessary methods to deploy and upgrade proxy contracts on ZKsync and EVM networks.

The injected `hre.upgrades`
object provides methods like `deployProxy` so deployment scripts work out of the box.

::callout{icon="i-heroicons-exclamation-triangle" color="amber"}
To avoid typescript collision errors between `@openzeppelin/hardhat-upgrades` and `@matterlabs/hardhat-zksync-upgradable` make sure that only the latter
(or the wrapper plugin `@matterlabs/hardhat-zksync`) is imported in the `hardhat.config.ts` file.
::

See examples below:

#### Deployment (Proxy)

::code-group

```typescript [@openzeppelin/contracts-upgradable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const boxFactory = await hre.ethers.getContractFactory("Box");
const box = await hre.upgrades.deployProxy(boxFactory, constructorArguments, {
   initializer: initializerFunctionName,
});
await box.waitForDeployment();
```

```typescript [hardhat-zksync-upgradeable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const boxFactory = await hre.ethers.getContractFactory("Box");
const box = await hre.upgrades.deployProxy(boxFactory, constructorArguments, {
  initializer: initializerFunctionName
});
await box.waitForDeployment();
```

::

#### Upgrade (Proxy)

::code-group

```typescript [@openzeppelin/hardhat-upgrades]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const upgradableProxyAddress = "UPGRADEABLE_PROXY_ADDRESS";
const boxV2ContractFactory = await hre.ethers.getContractFactory("BoxV2");
const boxV2 = await hre.upgrades.upgradeProxy(upgradableProxyAddress,boxV2ContractFactory);
await boxV2.waitForDeployment();
```

```typescript [hardhat-zksync-upgradeable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const upgradableProxyAddress = "UPGRADEABLE_PROXY_ADDRESS";
const boxV2ContractFactory = await hre.ethers.getContractFactory("BoxV2");
const boxV2 = await hre.zkUpgrades.upgradeProxy(upgradableProxyAddress,boxV2ContractFactory);
await boxV2.waitForDeployment();
```

::

#### Deployment (Beacon)

::code-group

```typescript [@openzeppelin/contracts-upgradable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const boxFactory = await hre.ethers.getContractFactory("Box");
const box = await hre.upgrades.deployBeacon(boxFactory, constructorArguments, {
   initializer: initializerFunctionName,
});
await box.waitForDeployment();
```

```typescript [hardhat-zksync-upgradeable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const boxFactory = await hre.ethers.getContractFactory("Box");
const box = await hre.upgrades.deployBeacon(boxFactory, constructorArguments, {
  initializer: initializerFunctionName
});
await box.waitForDeployment();
```

::

#### Upgrade (Beacon)

::code-group

```typescript [@openzeppelin/hardhat-upgrades]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const upgradableProxyAddress = "UPGRADEABLE_PROXY_ADDRESS";
const boxV2ContractFactory = await hre.ethers.getContractFactory("BoxV2");
const boxV2 = await hre.upgrades.upgradeProxy(upgradableProxyAddress, boxV2ContractFactory);
await boxV2.waitForDeployment();
```

```typescript [hardhat-zksync-upgradeable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const upgradableProxyAddress = "UPGRADEABLE_PROXY_ADDRESS";
const boxV2ContractFactory = await hre.ethers.getContractFactory("BoxV2");
const boxV2 = await hre.upgrades.upgradeProxy(upgradableProxyAddress, boxV2ContractFactory);
await boxV2.waitForDeployment();
```

::

### Custom deployment scripts with `hardhat-zksync`

Additionally, you can write custom deployment scripts for ZKsync leveraging the `hre.deployer` object which is injected automatically by `@matterlabs/hardhat-zksync-deploy`.
The `Deployer` class provides helper methods to deploy smart contracts to ZKsync. Find [more info here](https://docs.zksync.io/build/tooling/hardhat/hardhat-zksync-deploy#methods).

### Troubleshoting

- **Contract size too large:** if the size of the generated bytecode is too large and can not be deployed, try compiling
the contract with the `mode: 3` flag in the `hardhat.config.ts` file to
optimize the bytecode size on compilation. [More info here](https://docs.zksync.io/build/tooling/hardhat/hardhat-zksync-solc#configuration).

## Smart Contract Verification

<!-- TODO: pending rephrase -->
For ZKsync, the verification of a smart contracts does not differ from the commonly used verification process.

By installing `@matterlabs/hardhat-zksync`, a verification plugin is automatically added and ready to be used.

The only thing that is required to be modified is `hardhat.config.ts` file to include `verifyURL` in the network section.

::code-group

```typescript [url-zksync-sepolia-testnet]
  zkSyncSepoliaTestnet: {
    url: "https://sepolia.era.zksync.dev",
    ethNetwork: "sepolia",
    zksync: true,
    verifyURL: 'https://explorer.sepolia.era.zksync.dev/contract_verification'
  }
```

```typescript [url-zksync-mainnet]
  zkSyncMainnet: {
    url: "https://mainnet.era.zksync.io",
    ethNetwork: "mainnet",
    zksync: true,
    verifyURL: "https://zksync2-mainnet-explorer.zksync.io/contract_verification",
  },
```

::

You can run the verification task programmatically inside a script as follows:

```js
const verificationId = await hre.run("verify:verify", {
  address: contractAddress,
  contract: contractFullyQualifedName,
  constructorArguments: [...]
});
```

Or execute the verification task from your terminal running:

```sh
npm hardhat verify --network testnet 0x7cf08341524AAF292255F3ecD435f8EE1a910AbF "Hi there!"
```

Find more info in [this section of the documentation](/build/tooling/hardhat/hardhat-zksync-verify).

## Scripting

<!-- TODO: Include mention to API compatibility in zksync-ethers and viem -->
To be included.

## Multichain projects

Here are some recommendations projects that target multiple chains:

- Add the desired ZKsync networks with the `zksync:true` flag to the `hardhat.config.ts`.
- Make sure to run the compilation task with the `--network` flag when targeting ZKsync networks to use the custom compiler.
- The `@matterlabs/hardhat-zksync` plugin overrides the following plugins: `@nomiclabs/hardhat-ethers`, `@openzeppelin/hardhat-upgrades` when
targeting ZKsync chains, while maintaining their original features when targeting EVM networks.
- If you have different deployment scripts for
ZKsync, you can indicate the custom deployment folder for the ZKsync network using [the `deployPaths` property](/build/tooling/hardhat/hardhat-zksync-deploy#network-specific-deployment-paths):

```ts
const config: HardhatUserConfig = {
  networks: {
    sepolia: {
      url: "https://sepolia.infura.io/v3/<API_KEY>",
    },
    zksyncTestnet: {
      url: "https://sepolia.era.zksync.dev",
      ethNetwork: "sepolia",
      // ADDITION
      deployPaths: "deploy-zksync", //single deployment directory
      deployPaths: ["deploy", "deploy-zksync"], //multiple deployment directories
      zksync: true,
    },
  },
};
```
