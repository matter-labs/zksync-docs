---
title: Interfaces
description: Get familiar with ZKsync SSO interfaces
---

While the internal functionality can be quite complex, the external interfaces for developers are very simple.
This provides some technical information on how these components can be used.

### Auth Server

The entrypoint to the SDK is via the ``zksyncAccountConnector`` to connect to the *Auth Server*.
This takes the auth domain, session, and basic app information (name, icon). The fully expanded type looks like:

```ts
type ZKsyncAccountConnectorOptions = {
  metadata?: {
    name: string,
    icon?: string,
  },
  session?: {
    expiresAt?: Date| bigint;
    feeLimit?: bigint | ({ limit: bigint; period?: bigint; });
    callPolicies?: ({
        target: Address;
        function?: string | AbiFunction;
        selector?: Hash; // if function is not provided
        maxValuePerUse?: bigint;
        valueLimit?: bigint | Limit;
        constraints?: {
            index: number | bigint;
            condition?: Condition | keyof typeof Condition;
            refValue?: Hash;
            limit?: Limit;
        },
    })[];
    transferPolicies?: (
        target: Address;
        maxValuePerUse?: bigint;
        valueLimit?: bigint | Limit;)[];
  },
  authServerUrl?: string;
};
```

This returns a [WAGMI connector](https://wagmi.sh/core/api/connectors) that can be used to perform wallet-like
actions with the available account.
All of the functionality is then exposed via WAGMI,
making the ZKsync SSO account nearly indistinguishable from any other standard wallet provider!

## Sessions

Sessions' combination of function selector and multiple layers of limits makes them effective security measures,
but they must be configured correctly in order to be most specific to the expected use cases.
The session interface is also included with the account and passkey creation interfaces so sessions can be created
during any important user interactions.

```typescript
type CallPolicy = {
  target: Address;
  function?: string | AbiFunction;
  selector?: Hash; // if function is not provided
  maxValuePerUse?: bigint;
  valueLimit?: bigint | Limit;
  constraints?: {
    index: number | bigint;
    condition?: Condition | keyof typeof Condition;
    refValue?: Hash;
    limit?: Limit;
  }[];
};

type CallPolicy = {
  target: Address;
  function?: string | AbiFunction;
  selector?: Hash; // if function is not provided
  maxValuePerUse?: bigint;
  valueLimit?: bigint | Limit;
  constraints?: {
    index: number | bigint;
    condition?: Condition | keyof typeof Condition;
    refValue?: Hash;
    limit?: Limit;
  }[];
};

type CallPolicy = {
  target: Address;
  function?: string | AbiFunction;
  selector?: Hash; // if function is not provided
  maxValuePerUse?: bigint;
  valueLimit?: bigint | Limit;
  constraints?: {
    index: number | bigint;
    condition?: Condition | keyof typeof Condition;
    refValue?: Hash;
    limit?: Limit;
  }[];
};

type TransferPolicy = {
  target: Address;
  maxValuePerUse?: bigint;
  valueLimit?: bigint | Limit;
};

interface SessionPreferences {
  expiresAt?: bigint;
  feeLimit?: bigint | Limit;
  callPolicies?: CallPolicy[];
  transferPolicies?: TransferPolicy[];
};

```

This design was inspired by [Smart Sessions](https://github.com/erc7579/smartsessions/blob/main/contracts/external/policies/UniActionPolicy.sol).
For those looking to configure sessions to restrict access to functions,
understanding the storage layout of the sessions will help when setting the function selector and limits.

The split between call policy and transfer policy means that only *one* policy will be enforced per account transaction,
and it will be determined based on the amount of data provided.
4 or more bytes triggers the call policy, otherwise the transfer policy is applied.
