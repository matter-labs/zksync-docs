---
title: Interfaces
description: Get familiar with ZKsync SSO interfaces
---

There are 3 major components to the SDK: the hosted auth page, the client, and the contracts.
While the internal functionality can be quite complex, the external interfaces for developers are very simple.
This provides some technical information on how these components can be used.

### Auth Server

This should be the primary entry-point for those not-looking to create an embedded wallet experience.
The key entrypoint to the SDK is via the ``zksyncAccountConnector`` to connect to the *Auth Server*.
This takes the auth domain, session, and basic app information (name, icon). The fully expanded type looks like:

```ts
type ZKsyncAccountConnectorOptions = {
  metadata?: {
    name: string,
    icon?: string,
  },
  session?: {
    expiresAt?: Date| bigint;
    feeLimit?: bigint | ({ limit: bigint; period?: bigint; });
    callPolicies?: ({
        target: Address;
        function?: string | AbiFunction;
        selector?: Hash; // if function is not provided
        maxValuePerUse?: bigint;
        valueLimit?: bigint | Limit;
        constraints?: {
            index: number | bigint;
            condition?: Condition | keyof typeof Condition;
            refValue?: Hash;
            limit?: Limit;
        },
    })[];
    transferPolicies?: (
        target: Address;
        maxValuePerUse?: bigint;
        valueLimit?: bigint | Limit;)[];
  },
  authServerUrl?: string;
};
```

This returns a [WAGMI connector](https://wagmi.sh/core/api/connectors) that can be used to perform wallet-like
actions with the available account.
All of the functionality is then exposed via WAGMI,
making the ZKsync SSO account nearly indistinguishable from any other standard wallet provider!

### Client

For embedded wallet use cases that don't use the hosted auth solution,
the two key entry points are `registerNewPasskey` and `deployAccount`.
Adding a new passkey only really requires a username and the domain to store it for!

The passkey creation is handled by the simplewebauthn packages,
so it either takes the options to [generate](https://simplewebauthn.dev/docs/advanced/passkeys#generateregistrationoptions) a new key,
or it takes options to [login](https://simplewebauthn.dev/docs/packages/server#1-generate-authentication-options)
with an existing key!

Account deployment allows for changing the default modules included with the account,
so using the passkey or spend-limit modules here will hurt interoperability.
The deployment interface includes the following:

```ts
type DeployAccountArgs = {
  credentialPublicKey: Uint8Array; // Public key of the previously registered passkey
  paymasterAddress?: Address; // Paymaster used to pay the fees of creating accounts
  paymasterInput?: Hex; // Input for paymaster (if provided)
  expectedOrigin?: string; // Expected origin of the passkey
  uniqueAccountId?: string; // Unique account ID, can be omitted if you don't need it
  contracts: {
    accountFactory: Address;
    passkey: Address;
    session: Address;
  };
  initialSession?: SessionData;
  salt?: Uint8Array; // deployment hash
};
```

## Sessions

Sessions' combination of function selector and multiple layers of limits makes them effective security measures,
but they must be configured correctly in order to be most specific to the expected use cases.
The session interface is also included with the account and passkey creation interfaces so sessions can be created
during any important user interactions.

```typescript
type CallPolicy = {
  target: Address;
  function?: string | AbiFunction;
  selector?: Hash; // if function is not provided
  maxValuePerUse?: bigint;
  valueLimit?: bigint | Limit;
  constraints?: {
    index: number | bigint;
    condition?: Condition | keyof typeof Condition;
    refValue?: Hash;
    limit?: Limit;
  }[];
};

type CallPolicy = {
  target: Address;
  function?: string | AbiFunction;
  selector?: Hash; // if function is not provided
  maxValuePerUse?: bigint;
  valueLimit?: bigint | Limit;
  constraints?: {
    index: number | bigint;
    condition?: Condition | keyof typeof Condition;
    refValue?: Hash;
    limit?: Limit;
  }[];
};

type CallPolicy = {
  target: Address;
  function?: string | AbiFunction;
  selector?: Hash; // if function is not provided
  maxValuePerUse?: bigint;
  valueLimit?: bigint | Limit;
  constraints?: {
    index: number | bigint;
    condition?: Condition | keyof typeof Condition;
    refValue?: Hash;
    limit?: Limit;
  }[];
};

type TransferPolicy = {
  target: Address;
  maxValuePerUse?: bigint;
  valueLimit?: bigint | Limit;
};

interface SessionPreferences {
  expiresAt?: bigint;
  feeLimit?: bigint | Limit;
  callPolicies?: CallPolicy[];
  transferPolicies?: TransferPolicy[];
};

```

This design was inspired by [Smart Sessions](https://github.com/erc7579/smartsessions/blob/main/contracts/external/policies/UniActionPolicy.sol).
For those looking to configure sessions to restrict access to functions,
understanding the storage layout of the sessions will help when setting the function selector and limits.

The split between call policy and transfer policy means that only *one* policy will be enforced per account transaction,
and it will be determined based on the amount of data provided.
4 or more bytes triggers the call policy, otherwise the transfer policy is applied.

## Modules

It is important to clarify the distinction between the solidity module interface and the account interface:
the module interface specifies the methods that external contracts need to implement,
whereas the account interface defines the methods that the smart account must support.
When writing new custom modules it's helpful to know how accounts will interface, so both are provided here for completeness.

### ZKsync SSO Account specific functions

- `validateTransaction` - accepts a signature and the full transaction to execute, including paymaster information.
- `executeTransaction` - invoked by ZKsync's entry point to run a verified transaction
- `payForTransaction` and `prepareForPaymaster` - paymaster parsing functions called by the entry point to handle transaction fees and paymaster data.

### Account functions from 7579

- `executeFromExecutor` - a special entry point for modules that have been granted permission to execute within the smart account.
- `accountId` - returns a unique identifier for the contract type
- `supportsExecutionMode` - checks if a specific type of call data format is supported via entry points
- `supportModule` - verifies if a module type (1-4) is available on the account
- `installModule` - adds a module to the account
- `uninstallModule` - removes a module from the account
- `isModuleInstalled` - checks if a module is installed on the account

### Hooks

- `preCheck` - called before the execution flow begins
- `postCheck` - called after the execution flow completes

### 4337 Module flow specific functions

- `validateUserOp` - performs validation of a user operation as defined in ERC-4337
- `executeUserOp` - called by the ERC-4337 account entry point after validations are successful to execute the user operation

### ZKsync Module flow specific functions

- `handleTransaction` - uses the same format as EIP1271 `isValidSignature`
  - Returns true/false instead of a magic success number, easily wrapping an `isValidSignature` call
  - Installs via `installModule` as a validation module type
- `validationHook` - uses the same format as `validateTransaction`
  - Installs via `installHook` , not considered a module.
  This is an optional alternative interface as part of the validation module type.
