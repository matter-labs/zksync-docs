---
title: ZKsync OS Server
description: Overview of the ZKsync OS sequencer.
---

The ZKsync OS Sever is a complex system composed of several services and modules that work together to monitor Ethereum Layer 1 (L1),
maintain Layer 2 (L2) state, and manage the order of incoming transactions.

The new sequencer can process **over 10,000 transactions per second** through a single-binary architecture that dramatically reduces operational overhead.
The system scales horizontally through Elastic Nodes, delivering enterprise performance without enterprise complexity or costs.

With the ZKsync OS Sequencer, transaction costs drop to **$0.0001 per transaction**, a 99% reduction from Layer 1 solutions.
This enables microtransactions, high-frequency applications, and business models that weren't economically viable before.

## Components

The server implementation consists of three main subsystems:

1. [Sequencer](https://github.com/matter-labs/zksync-os-server/tree/main/lib/sequencer):
  Executes transactions and sends the results downstream to other components.
1. [RPC API](https://github.com/matter-labs/zksync-os-server/tree/main/lib/rpc_api):
  Implementation of the Web3 JSON-RPC API.
1. [Batcher](https://github.com/matter-labs/zksync-os-server/tree/main/node/bin/src/batcher):
  Turns a stream of blocks into a stream of batches (1 batch = 1 proof = 1 L1 commit),
  exposes prover APIs, and submits batches and proofs to L1.

For a more detailed overview, please refer to the [ZKsync OS Server GitHub repository](https://github.com/matter-labs/zksync-os-server).

## Design Principles

The three main design principles that were used for the server are:

1. **Minimal, async persistence** to meet throughput and latency requirements.
  Synchronous persistence is avoided at the critical path.
  Additionally, the sequencer aims at storing only the data that is strictly needed, minimizing the potential for state inconsistency.
1. **Easy to replay arbitrary blocks**.
    The sequencer components are idempotent.
    The batcher component skips all blocks until the first uncommitted batch.
    Thus, downstream components only receive batches that they need need to act upon.
1. **Strong separation between states**.
  The actual state only includes data needed to execute the VM: key-value storage and a preimages map.
  The receipts repositories includes data only needed in the API.
  The data related to proofs and L1, which is not needed by the sequencer or JSON RPC, is only introduced downstream from batcher.
